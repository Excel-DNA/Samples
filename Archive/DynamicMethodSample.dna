<DnaLibrary RuntimeVersion="v4.0" Name="ExcelDna Test Dynamic Method" Language="C#">
  <!--
    This example shows how to dynamically create a method and register it.
  -->
  
  <![CDATA[
  using System;
  using System.Collections.Generic;
  using System.Reflection;
  using System.Reflection.Emit;
  using ExcelDna.Integration;

  public class Test : IExcelAddIn
  {
    public void AutoOpen()
    {
        DynamicMethod mult = new DynamicMethod("MyMultiply",
                                  typeof(double),
                                  new Type[] { typeof(double), typeof(double) },
                                  typeof(Test));
        ILGenerator il = mult.GetILGenerator();
        il.Emit(OpCodes.Ldarg_0);
        il.Emit(OpCodes.Ldarg_1);
        il.Emit(OpCodes.Mul);
        il.Emit(OpCodes.Ret);
        // Method will be completed when CreateDelegate is called during registration.

        // Registration takes a list of Delegates - the registration
        // creates a new assembly and a type every time it is called.
        List<Delegate> delegates = new List<Delegate>();
        delegates.Add(mult.CreateDelegate(typeof(Func<double, double, double>)));

        // We can also create some attributes to customize the function registration:
        ExcelFunctionAttribute att = new ExcelFunctionAttribute();
        att.Name = "MyMultiply";
        att.Description = "A function to multiply two numbers";

        List<object> funcAttribs = new List<object>();
        funcAttribs.Add(att);

        ExcelArgumentAttribute atta1 = new ExcelArgumentAttribute();
        atta1.Description = "is the first number";

        ExcelArgumentAttribute atta2 = new ExcelArgumentAttribute();
        atta2.Description = "is the second number";

        List<object> argAttribs = new List<object>();
        argAttribs.Add(atta1);
        argAttribs.Add(atta2);

        List<List<object>> argAttribsList = new List<List<object>>();
        argAttribsList.Add(argAttribs);

        ExcelIntegration.RegisterDelegates(delegates, funcAttribs, argAttribsList);
    }

    public void AutoClose()
    {
    }

    public static double MyAdd(double d1, double d2)
    {
      return d1 + d2;
    }
    
    public static double MyMean(double[] values)
    {
      if (values.Length == 0)
        return double.NaN;

      double sum = 0;
      for (int i = 0; i < values.Length; i++)
      {
        sum += values[i];
      }
      return sum / values.Length;
    }

    public static double MyMeanObjects(object[] values)
    {
      int length = 0;
      double sum = 0;
      for (int i = 0; i < values.Length; i++)
      {
        if (values[i] is double)
        {
          double d = (double)values[i];
          length++;
          sum += d;
        }
      }
      return sum / length;
    }
}
  ]]>
</DnaLibrary>
